/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model. All user data is private and can only be accessed by the authenticated user who owns it. This is a highly secure and scalable model for applications where user data must be isolated.
 *
 * Data Structure: All user-specific data is stored in a top-level `/users` collection. Each user's data is contained within a document where the document ID is the user's unique Firebase Authentication UID (e.g., `/users/{userId}`).
 *
 * Key Security Decisions:
 * - User Isolation: A user can ONLY read, write, and delete their own document in the `/users` collection.
 * - No User Listing: Listing the entire `/users` collection is explicitly disallowed to prevent data scraping and protect user privacy.
 * - Secure By Default: Access is denied by default. No operation is permitted unless an explicit `allow` rule grants it.
 * - Self-Creation: A newly authenticated user is permitted to create their own user profile document, which is essential for registration flows.
 *
 * Denormalization for Authorization: No denormalization is required for this simple structure. Authorization decisions are made using the document's path (`/users/{userId}`), which is the most performant and secure method for this model.
 *
 * Structural Segregation: This pattern is not currently used as there is no distinction between public and private user data in the requirements. All user data is treated as private.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the provided userId.
     * This is the foundation of the user-ownership model.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * For update/delete operations, checks for ownership AND that the document exists.
     * This prevents writes to non-existent documents.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Validates required fields for creating a new user document.
     * Enforces that the document's internal `id` field matches the user's auth UID.
     * This ensures relational integrity between the auth system and the database.
     */
    function isValidUserCreate(userId) {
      return request.resource.data.id == userId;
    }

    /**
     * Validates required fields during a user document update.
     * Enforces that the core `id` field is immutable and cannot be changed after creation.
     */
    function isImmutableUserId() {
      return request.resource.data.id == resource.data.id;
    }

    // ------------------------------------------------------------------------
    // Collection Rules
    // ------------------------------------------------------------------------

    /**
     * @description Manages user profile documents. A user can only access their own document.
     * @path /users/{userId}
     * @allow (get) A user with UID 'user123' can read their own document at `/users/user123`.
     * @allow (create) A new user 'user123' can create their own document at `/users/user123`.
     * @deny (get) A user 'userABC' is denied access to `/users/user123`.
     * @deny (list) No user can list all documents in the `/users` collection.
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && isValidUserCreate(userId);
      allow update: if isExistingOwner(userId) && isImmutableUserId();
      allow delete: if isExistingOwner(userId);
    }
  }
}